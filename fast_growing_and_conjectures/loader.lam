let
  id = \x.x;
  -- function composition
  comp = \f\g\x. f (g x);
  -- Church numerals
  C0 = \f\x.x;
  C1 = id;
  Csucc = \n\f\x. f (n f x);
  C2 = Csucc C1;
  C3 = Csucc C2;
  Cadd = \m\n\f\x. m f (n f x);
  Cmul = comp;
  Cpow = \m\n. n m;
  -- Scott numerals
  Ssucc = \n\s\z. s n;
  Spred = \n. n (\n1. n1) n;
  S0    = \s\z. z;
  S1    = Ssucc S0;
  -- Booleans
  T = \x\y. x;
  F = \x\y. y;
  not = \b\t\f. b f t;
  eqb = \b1\b2.b1 b2 (not b2); -- boolean equality	30 bits
  -- list ops
  nil = F;
  cons = \x\y\z.z x y;

  -- list equality		146 bits
  eql = \eq. let go = \l\m. l (\t\l1\_. (m (\t2\m1\m. eq t t2 (go l1 m1) F) m)) (m (\b\m1\_. l) T) in go;

  -- term constructors
  pilam = \b\ta\tb \pla\bs\vr. pla (Ssucc b) ta tb;
  app   =   \ta\tb \pla\bs\vr. pla S0        ta tb;
  boxstar =  \b    \pla\bs\vr. bs b;
  var   = \v       \pla\bs\vr. vr v;
  box   = boxstar T;
  star  = boxstar F;

  -- serialize			263 bits
  ser = \t\l. let cT = cons T; cF = cons F in t -- DECON
    (\mb. \ta\tb. cT (mb (\b\tail. cT (cons b tail)) cF (ser ta (ser tb l))))
    (\b        . cF (cT (cons b l)))
    (let go=\v . cF (cF (v go (cT l))) in go)
    -- 6 bits less than ((\v . cF (cF (v (\v1. ser (var v1)) cT l)))
  ;

  -- term equality		459 bits
  eqt = \t1\t2. eql eqb (ser t1 nil) (ser t2 nil);

  -- context equality		500 bits
  eqc = eql eqt;

  -- help define lift twice, in and out of subst mutual recursion
  slift = \sub. sub S0 (var S1) Ssucc;

  -- substitute term e for variable v in term t, applying d to outer variables
  subst = \v\e\d\t. let		-- 555 bits
    apply = \f\a.let kfa = \_. app f a in f -- DECON
      (\mb\ta. mb (\b. b kfa (subst S0 a Spred)) kfa)
      (     kfa)
      (     kfa)
    ;
    lift = slift subst;
    sved = subst v e d
  in t -- DECON
    (\mb\ta\tb. mb (\b. pilam b (sved ta) (subst (Ssucc v) (lift e) d tb)) (apply (sved ta) (sved tb)))
    (\b      . t)
    (\w      . let cmp = \v\u. v (\v1. u (cmp v1) t) (u (\u1. var (d w)) e) in cmp v w)
  ;

  -- whether a given term is either box or star		38 bits
  -- serializing and testing initial bits takes more even when sorts are T T
  isSort = \srt\t\f. srt -- DECON
    (\mb\ta\tb. f)
    (\b       . t)
    (\w       . f)
  ;

-- either this or implement mutual recursion on subst + apply + lift
-- 				582 bits
  lift = slift subst;
-- 				626 bits
  apply = \f\a. subst S0 (var S0) id (app f a);

  judge = \ctx\trm\typ\z.z ctx trm typ;

-- rule 1
  axiom = cons (judge nil star box);

-- rule 3+6			1603 bits
  weakenApp = \jdg\jdg2. jdg (\ctx\trm\typ. jdg2 (\ctx2\trm2\typ2\tail. eqc ctx ctx2 (
   let tail2 = typ -- DECON
     (\mb\ta\tb. mb (\b. eqt ta typ2 (cons (judge ctx2 (apply trm trm2) (subst S0 trm2 Spred tb))) id) id tail)
     (\b      . tail)
     (\w      . tail)
   in isSort typ2 (cons (judge (cons trm2 ctx2) (lift trm) (lift typ))) id tail2) tail));

-- rule 2+4+5			936 bits
  iVarLamPi = \jdg. jdg (\ctx\trm\typ \tail.
    let
      b = isSort typ;
      tail2 = ctx (\tp\ctx1. cons (judge ctx1 (pilam b tp trm) (b id (pilam T tp) typ))) tail
    in b (cons (judge (cons trm ctx) (var S0) (lift trm))) id tail2);
  
  fold = \f\z. let go = \l. l (\h\t\z.f h (go t)) z in go;	-- 69 bits

-- expand list of judgements	2205 bits
  expand = \l. fold (\j1. fold (\j2. comp (weakenApp j1 j2)) (iVarLamPi j1) l) (axiom nil) l;

-- list length		75 bits
  length = fold (\_. Csucc) C0;

  -- term size		390 bits
  size = \t. length (ser t nil);

  -- exponential tower judgement list size	459 bits
  jlsize = fold (\jdg. jdg (\ctx\trm\typ. Cpow (size trm))) C1;

  -- judgement list size			485 bits
  lsize = fold (\jdg. jdg (\ctx\trm\typ \sz. Cadd sz (size trm))) C0;

-- derive			2351 bits
  derive = \n. jlsize (n expand nil)

in derive -- length (Cmul C2 C3 expand nil)

-- C0 expand nil -- \\1
--                  nil
-- C1 expand nil -- \1 (\1 (\\1) (\\\\2 (\\1)) (\\\\2 (\\2))) (\\1)
--                  cons (Judge nil star box) nil
-- C2 expand nil -- \1 (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\2 (\\1)) (\\\\2 (\\2))) (\1 (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\1 (\\1)) (\\\\2 (\\1))) (\1 (\1 (\\1) (\\\\2 (\\1)) (\\\\2 (\\2))) (\\1)))
--                  cons (Judge (cons star nil) star box)
--                 (cons (Judge (cons star nil) (var S0) star)
--                 (cons (Judge nil star box)
--                  nil))
-- C3 expand nil -- \1 (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\2 (\\1)) (\\\\2 (\\2))) (\1 (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\2 (\\1)) (\\\\2 (\\2))) (\1 (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\1)) (\\\\2 (\\1))) (\1 (\1 (\\1) (\\\\4 (\\2) (\\\\2 (\\1)) (\\\\2 (\\1))) (\\\\2 (\\2))) (\1 (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\2 (\\1))) (\\\\2 (\\1))) (\1 (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\2 (\\1))) (\\\\2 (\\1))) (\1 (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\1)) (\\\\1 (\\2 (\\1)))) (\1 (\1 (\\1) (\\\\4 (\\2) (\\\\2 (\\1)) (\\\\1 (\\1))) (\\\\2 (\\1))) (\1 (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\2 (\\1)) (\\\\2 (\\2))) (\1 (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\1 (\\1)) (\\\\2 (\\1))) (\1 (\1 (\\1) (\\\\2 (\\1)) (\\\\2 (\\2))) (\\1)))))))))))
--                  cons (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\2 (\\1)) (\\\\2 (\\2)))
--                 (cons (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\2 (\\1)) (\\\\2 (\\2)))
--                 (cons (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\1)) (\\\\2 (\\1)))
--                 (cons (\1 (\\1) (\\\\4 (\\2) (\\\\2 (\\1)) (\\\\2 (\\1))) (\\\\2 (\\2)))
--                 (cons (\1 (\1 (\\\\2 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\2 (\\1))) (\\\\2 (\\1)))
--                 (cons (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\2 (\\1))) (\\\\2 (\\1)))
--                 (cons (\1 (\1 (\\\\1 (\\1)) (\1 (\\\\2 (\\1)) (\\1))) (\\\\1 (\\1)) (\\\\1 (\\2 (\\1))))
--                 (cons (\1 (\\1) (\\\\4 (\\2) (\\\\2 (\\1)) (\\\\1 (\\1))) (\\\\2 (\\1)))
--                 (cons (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\2 (\\1)) (\\\\2 (\\2)))
--                 (cons (\1 (\1 (\\\\2 (\\1)) (\\1)) (\\\\1 (\\1)) (\\\\2 (\\1)))
--                 (cons (\1 (\\1) (\\\\2 (\\1)) (\\\\2 (\\2)))
--                 nil)))))))))))
