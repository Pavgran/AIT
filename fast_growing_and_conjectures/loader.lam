let derive = (let
  id = \x.x;
  -- function composition
  comp = \f\g\x. f (g x);
  -- Church numerals
  C0 = \f\x.x;
  C1 = id;
  Csucc = \n\f\x. f (n f x);
  C2 = Csucc C1;
  Cadd = \m\n\f\x. m f (n f x);
  Cmul = comp;
  Cpow = \m\n. n m;
  -- Scott numerals
  Ssucc = \n\s\z. s n;
  Spred = \n. n (\n1. n1) n;
  S0    = \s\z. z;
  S1    = Ssucc S0;
  -- Booleans
  T = \x\y. x;
  F = \x\y. y;
  not = \b\t\f. b f t;
  eqb = \b1\b2.b1 b2 (b2 b1 T); -- boolean equality	29 bits -- found by Marvin Borner
  -- list ops
  nil = F;
  cons = \x\y\z.z x y;
  head = \l.l T;
  tail = \l.l F;
  -- Drop numerals
  D0    = id;
  Dsucc = \drop\list. drop list F;

  judge = \ctx\typ\trm\z.z ctx typ trm;

  -- list equality		146 bits
  eql = \eq. let go = \l\m. l (\t\l1\_. m (\t2\m1\m. eq t t2 (go l1 m1) F) m) (m (\b\m1\_. l) T) in go;

  -- term constructors
  pilam   = \bp\ta\tb \pla\bs\vr. pla (Ssucc bp) ta tb;
  app     = \ta\tb    \pla\bs\vr. pla S0 ta tb;
  sort    = \bx       \pla\bs\vr. bs bx;
  var     = \v        \pla\bs\vr. vr v;

  -- environment of free variables [C1 consF, C2 consF, .. ]
  freevars = let
    go = \pre. let preF = \tl. cons F (pre tl) in cons (var preF) (go preF)
  in go id;

  -- close an open term
  close = \ot. ot freevars;

  -- serialize closed term t before list tl at abstraction depth d		??? bits
  sers = \d\t\tl. let cT = cons T; cF = cons F in t
    (\mb\ta\tb. cT (sers d ta (mb (\bp. cT (cons bp (sers (Csucc d) (tb (var (d tail))) tl)))
                                  (cF (sers d tb tl)))))
    (\bx.       cF (cT (cons bx tl)))
    (\v.        v (d cF (cF (cT tl))));

  -- serialize an open term
  ser = \ot. sers C0 (close ot) nil;

  -- open term equality		??? bits
  eqt = \ot1\ot2. eql eqb (ser ot1) (ser ot2);

  -- context equality		??? bits
  eqc = eql eqt;

  -- lift an open term
  lift = \ot\env. ot (tail env);

  -- rules 2+3+4+5+6		-- ??? bits
  rules = \jdg1\jdg2. jdg1 (\ctx\typ\trm. jdg2 (\ctx2\typ2\trm2. eqc ctx ctx2 (
    let
      isSort = close typ2
        (\mb\ta\tb. F)
        (\bx.       T)
        (\v.        F);
      weaken = isSort (cons (judge (cons trm2 ctx2) (lift typ) (lift trm))) id;
      iLamPi = ctx2 (\tp\ctx21. cons ( let
           abstract = \bp\ta\fb. \env. (pilam bp (ta env) (\x. fb (cons x env)))
         in judge ctx21 (isSort id (abstract T tp) typ2) (abstract isSort tp trm2)));
      iVar   = \tl. isSort (cons (judge (cons trm2 ctx2) (lift trm2) head) tl) tl;
      iApp   = close typ
        (\mb\ta. mb (\bp. eqt (\_.ta) typ2 (\tb. cons (let
          apply = \ot1\ot2. \env. let t1 = ot1 env in t1
              (\mb\ta\tb. mb (\bp. tb))
              (\bx.       id)
              (\v.        id)
            (app t1) (ot2 env)
         in judge ctx2 (apply typ trm2) (apply trm trm2)))))
        (\bx.       id)
        (\v.        id)
    in \tl. weaken (iApp (iLamPi (iVar tl)))
  ) id));

  in \n. let
    ffold = \f. let go = \l.l (\h\t\z.f h (go t z)) in go; -- fold with 2nd/3rd arguments flipped
    axiom = judge nil (\_. sort T) (\_. sort F);
    expand = \l. ffold (\j1. ffold (\j2. comp (rules j1 j2)) l id) l (cons axiom nil);
    sizetower = ffold (\jdg. jdg (\ctx\typ\trm. Cpow (ffold (\_. Csucc) (ser trm) C1)))
    -- length = \l. ffold (\_. Csucc) l C0;
  in sizetower (n expand nil) n);

  3 = \f\x. f (f (f x))
in 3 3 derive 3
