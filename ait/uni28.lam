-- universal machine for Levenshtein binary lambda calculus (BLC2)
let
 id = \x.x;
 true = \x\y.x;
 false = \x\y.y;

 -- readbit f cont n input = cont (n . n . if next_input_bit then f else id) input'
 readbit = \f\cont\n\inp.inp (\_\bit.cont (\x. n (n (bit x (f x)))));

 -- delimit f cont (levenstein_code_for_n_on_input) = cont (f^n) input'
 delimit = \f\cont\inp.inp (\_\bit.bit (cont id) (delimit (readbit f) (\n. n cont f)));

  -- binary LC interpreter
  -- int2 cont input = cont (\free.parsed) input'
  int2 = \cont\inp.inp (\_\bit0. bit0
    (\inp1.inp1 (\_\bit1.
       int2 (\exp.bit1 (cont (\args\arg.exp (\z.z arg args)))
                       (int2 (\exp2.cont (\args.exp args (exp2 args)))))))
    (delimit (\l.l bit0) (\n. cont (\args. n args true))));
  
  -- input cont = cont bytes nextbit nextinput
  input = \bits\bytes\cont. let go = \bs\bit\bits1\z. cont bytes bit (input bits1 bs)
                         in bits (go bytes) (bytes (\byte\bytes1. byte (go bytes1) bytes1));

  -- loop
  omega = omega;

  -- binary LC universal machine for closed programs
  uni2 = \bytes.int2 (\exp\inp.inp(\bytes\_\_. exp omega bytes)) (input false bytes)
in uni2
