-- nf outputs the normal form of the input blc term
let
  id    = \x.x;
  true  = \t\f.t;
  false = \t\f.f;
  nil   = false;
  cons  = \x\y\z. z x y;
  cons0 = cons true;
  cons1 = cons false;
  compose = \f\g\x. f (g x);
  cons00 = compose cons0 cons0;
  cons01 = compose cons0 cons1;
  cons10 = compose cons1 cons0;
  tail = \l. l false;
  succ = \n\f\x.f (n f x);
  zero = false;
  one = id;

  -- data T = L (T -> T)  -- Lam
  --        | A T T       -- App
  --        | V Int       -- de Bruijn level variable 
  caseT = \t\l\a\v. t l a v;
  L = \f.     \l\a\v. l f;
  A = \t1\t2. \l\a\v. a t1 t2;
  V = \d.     \l\a\v. v d;

  parseval = \cont\xs.
    xs (\b0\ys\parseval\cont.ys (\b1. b0
       (parseval (\t1.(b1 (cont (\ctx. L (\v.t1 (\p.p v ctx))))
         (parseval (\t2.cont (\ctx. let
           tc1 = t1 ctx; tc2 = t2 ctx; A12 = A tc1 tc2
         in tc1 (\f. f tc2) (\_\_. A12) (\_. A12)
         ))))))
       (b1 (cont (\ctx. ctx b1))
                 (\d.parseval (\v.cont (\ctx. v (ctx b1))) ys))))
       parseval cont;

  ser = \lvl\t. caseT t
    -- Lambda: apply to a free variable to further reduce whnf
    (\f.     compose cons00 (ser (succ lvl) (f (V lvl))))
    -- Application
    (\t1\t2. compose cons01 (compose (ser lvl t1) (ser lvl t2)))
    -- Variable
    (\v.     compose (v tail) (compose (lvl cons1) cons0));

  omega = omega;
  nf = parseval (\t. ser one (t omega))
in nf
