--         1   1   1 * 2   1 * 2 * 3   1 * 2 * 3 * 4
-- pi/2 =  - + - + ----- + --------- + ------------- + ...
--         1   3   3 * 5   3 * 5 * 7   3 * 5 * 7 * 9
-- since each term is less than halve of previous one
-- sum first n terms < pi/2 < sum first n terms + n'th term
-- a/c is 2^j times the sum of the first n terms minus the value of the j bits already output
-- b/c is 2^j times the n-th term product [1..n] / product [1,3..2*n+1]
-- halfpi = go 1 1 1 1 where
-- go b a c = let
--     prod bit a' n = bit : go (2*b) (2*a') c n
--   in if a >= c
--     then   \n. 1 : go (2*b) (2*(a-c) )  c       n
--     else if a + b < c
--       then \n. 0 : go (2*b) (2* a    )  c       n
--       else \n -> let
--         n21 = 2*n + 1
--         bn = b*n
--       in           go    bn (a*n21+bn) (c*n21) (n+1)

\io. let
  id = \x. x;
  bit0 = \x0\x1. x0;
  bit1 = \x0\x1. x1;
  cons = \a\b\p. p a b;
  -- Church numerals
  C1 = id;
  Csucc = \n\f\x. f (n f x);
  Cadd = \a\b\f\x. a f (b f x);
  -- Tuple numerals
  -- Tm x (Tn y) = if n < m then y (Tm-1-n x) else x (Tn-m y)
  T1 = \x\f. f x;
  Tadd = \tm\tn\x. tm (tn x);
  CTmul = \c\t. c t;
  Tsub = \tm\tn\x. tm id (tn x);

  go = \Tb\Ta\Tc. let
      prod = \bit\Ta'\Cn. cons bit (go (Tadd Tb Tb) (Tadd Ta' Ta') Tc Cn) in
      (Tc (\_. prod bit1 (Tsub Tc Ta)))      -- case Ta >= Tc
      (Ta (\_.                               -- case Ta < Tc
         (Tc
             (\_\Cn. let                     -- case Ta+Tb >= Tc
                    x2np1 = CTmul (Csucc (Cadd Cn Cn));
                    CnxTb = CTmul Cn Tb
              in go CnxTb (Tadd (x2np1 Ta) CnxTb) (x2np1 Tc) (Csucc Cn)))
         (Ta (Tb (\_. prod bit0 Ta)))        -- case Ta+Tb < Tc
      ));

  pi = go T1 T1 T1 C1;
in pi
